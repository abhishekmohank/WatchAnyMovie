{"version":3,"file":"index.js","sources":["../../src/domain.ts","../../src/domain-without-suffix.ts","../../src/extract-hostname.ts","../../src/is-ip.ts","../../src/is-valid.ts","../../src/options.ts","../../src/subdomain.ts","../../src/factory.ts","../../src/lookup/fast-path.ts"],"sourcesContent":["import { IOptions } from './options';\n\n/**\n * Check if `vhost` is a valid suffix of `hostname` (top-domain)\n *\n * It means that `vhost` needs to be a suffix of `hostname` and we then need to\n * make sure that: either they are equal, or the character preceding `vhost` in\n * `hostname` is a '.' (it should not be a partial label).\n *\n * * hostname = 'not.evil.com' and vhost = 'vil.com'      => not ok\n * * hostname = 'not.evil.com' and vhost = 'evil.com'     => ok\n * * hostname = 'not.evil.com' and vhost = 'not.evil.com' => ok\n */\nfunction shareSameDomainSuffix(hostname: string, vhost: string): boolean {\n  if (hostname.endsWith(vhost)) {\n    return (\n      hostname.length === vhost.length ||\n      hostname[hostname.length - vhost.length - 1] === '.'\n    );\n  }\n\n  return false;\n}\n\n/**\n * Given a hostname and its public suffix, extract the general domain.\n */\nfunction extractDomainWithSuffix(\n  hostname: string,\n  publicSuffix: string,\n): string {\n  // Locate the index of the last '.' in the part of the `hostname` preceding\n  // the public suffix.\n  //\n  // examples:\n  //   1. not.evil.co.uk  => evil.co.uk\n  //         ^    ^\n  //         |    | start of public suffix\n  //         | index of the last dot\n  //\n  //   2. example.co.uk   => example.co.uk\n  //     ^       ^\n  //     |       | start of public suffix\n  //     |\n  //     | (-1) no dot found before the public suffix\n  const publicSuffixIndex = hostname.length - publicSuffix.length - 2;\n  const lastDotBeforeSuffixIndex = hostname.lastIndexOf('.', publicSuffixIndex);\n\n  // No '.' found, then `hostname` is the general domain (no sub-domain)\n  if (lastDotBeforeSuffixIndex === -1) {\n    return hostname;\n  }\n\n  // Extract the part between the last '.'\n  return hostname.slice(lastDotBeforeSuffixIndex + 1);\n}\n\n/**\n * Detects the domain based on rules and upon and a host string\n */\nexport default function getDomain(\n  suffix: string,\n  hostname: string,\n  options: IOptions,\n): string | null {\n  // Check if `hostname` ends with a member of `validHosts`.\n  if (options.validHosts !== null) {\n    const validHosts = options.validHosts;\n    for (let i = 0; i < validHosts.length; i += 1) {\n      const vhost = validHosts[i];\n      if (shareSameDomainSuffix(hostname, vhost)) {\n        return vhost;\n      }\n    }\n  }\n\n  // If `hostname` is a valid public suffix, then there is no domain to return.\n  // Since we already know that `getPublicSuffix` returns a suffix of `hostname`\n  // there is no need to perform a string comparison and we only compare the\n  // size.\n  if (suffix.length === hostname.length) {\n    return null;\n  }\n\n  // To extract the general domain, we start by identifying the public suffix\n  // (if any), then consider the domain to be the public suffix with one added\n  // level of depth. (e.g.: if hostname is `not.evil.co.uk` and public suffix:\n  // `co.uk`, then we take one more level: `evil`, giving the final result:\n  // `evil.co.uk`).\n  return extractDomainWithSuffix(hostname, suffix);\n}\n","\n/**\n * Return the part of domain without suffix.\n *\n * Example: for domain 'foo.com', the result would be 'foo'.\n */\nexport default function getDomainWithoutSuffix(domain: string, suffix: string): string {\n  // Note: here `domain` and `suffix` cannot have the same length because in\n  // this case we set `domain` to `null` instead. It is thus safe to assume\n  // that `suffix` is shorter than `domain`.\n  return domain.slice(0, -suffix.length - 1);\n}\n","/**\n * @param url - URL we want to extract a hostname from.\n * @param urlIsValidHostname - hint from caller; true if `url` is already a valid hostname.\n */\nexport default function extractHostname(\n  url: string,\n  urlIsValidHostname: boolean,\n): string | null {\n  let start: number = 0;\n  let end: number = url.length;\n  let hasUpper: boolean = false;\n\n  // If url is not already a valid hostname, then try to extract hostname.\n  if (urlIsValidHostname === false) {\n    // Special handling of data URLs\n    if (url.startsWith('data:') === true) {\n      return null;\n    }\n\n    // Trim leading spaces\n    while (start < url.length && url.charCodeAt(start) <= 32) {\n      start += 1;\n    }\n\n    // Trim trailing spaces\n    while (end > start + 1 && url.charCodeAt(end - 1) <= 32) {\n      end -= 1;\n    }\n\n    // Skip scheme.\n    if (\n      url.charCodeAt(start) === 47 /* '/' */ &&\n      url.charCodeAt(start + 1) === 47 /* '/' */\n    ) {\n      start += 2;\n    } else {\n      const indexOfProtocol = url.indexOf(':/', start);\n      if (indexOfProtocol !== -1) {\n        // Implement fast-path for common protocols. We expect most protocols\n        // should be one of these 4 and thus we will not need to perform the\n        // more expansive validity check most of the time.\n        const protocolSize = indexOfProtocol - start;\n        const c0 = url.charCodeAt(start);\n        const c1 = url.charCodeAt(start + 1);\n        const c2 = url.charCodeAt(start + 2);\n        const c3 = url.charCodeAt(start + 3);\n        const c4 = url.charCodeAt(start + 4);\n\n        if (\n          protocolSize === 5 &&\n          c0 === 104 /* 'h' */ &&\n          c1 === 116 /* 't' */ &&\n          c2 === 116 /* 't' */ &&\n          c3 === 112 /* 'p' */ &&\n          c4 === 115 /* 's' */\n        ) {\n          // https\n        } else if (\n          protocolSize === 4 &&\n          c0 === 104 /* 'h' */ &&\n          c1 === 116 /* 't' */ &&\n          c2 === 116 /* 't' */ &&\n          c3 === 112 /* 'p' */\n        ) {\n          // http\n        } else if (\n          protocolSize === 3 &&\n          c0 === 119 /* 'w' */ &&\n          c1 === 115 /* 's' */ &&\n          c2 === 115 /* 's' */\n        ) {\n          // wss\n        } else if (\n          protocolSize === 2 &&\n          c0 === 119 /* 'w' */ &&\n          c1 === 115 /* 's' */\n        ) {\n          // ws\n        } else {\n          // Check that scheme is valid\n          for (let i = start; i < indexOfProtocol; i += 1) {\n            const lowerCaseCode = url.charCodeAt(i) | 32;\n            if (\n              ((lowerCaseCode >= 97 && lowerCaseCode <= 122) || // [a, z]\n              (lowerCaseCode >= 48 && lowerCaseCode <= 57) || // [0, 9]\n              lowerCaseCode === 46 || // '.'\n              lowerCaseCode === 45 || // '-'\n                lowerCaseCode === 43) === false // '+'\n            ) {\n              return null;\n            }\n          }\n        }\n\n        // Skip 0, 1 or more '/' after ':/'\n        start = indexOfProtocol + 2;\n        while (url.charCodeAt(start) === 47 /* '/' */) {\n          start += 1;\n        }\n      }\n    }\n\n    // Detect first occurrence of '/', '?' or '#'. We also keep track of the\n    // last occurrence of '@', ']' or ':' to speed-up subsequent parsing of\n    // (respectively), identifier, ipv6 or port.\n    let indexOfIdentifier: number = -1;\n    let indexOfClosingBracket: number = -1;\n    let indexOfPort: number = -1;\n    for (let i = start; i < end; i += 1) {\n      const code: number = url.charCodeAt(i);\n      if (\n        code === 35 || // '#'\n        code === 47 || // '/'\n        code === 63 // '?'\n      ) {\n        end = i;\n        break;\n      } else if (code === 64) {\n        // '@'\n        indexOfIdentifier = i;\n      } else if (code === 93) {\n        // ']'\n        indexOfClosingBracket = i;\n      } else if (code === 58) {\n        // ':'\n        indexOfPort = i;\n      } else if (code >= 65 && code <= 90) {\n        hasUpper = true;\n      }\n    }\n\n    // Detect identifier: '@'\n    if (\n      indexOfIdentifier !== -1 &&\n      indexOfIdentifier > start &&\n      indexOfIdentifier < end\n    ) {\n      start = indexOfIdentifier + 1;\n    }\n\n    // Handle ipv6 addresses\n    if (url.charCodeAt(start) === 91 /* '[' */) {\n      if (indexOfClosingBracket !== -1) {\n        return url.slice(start + 1, indexOfClosingBracket).toLowerCase();\n      }\n      return null;\n    } else if (indexOfPort !== -1 && indexOfPort > start && indexOfPort < end) {\n      // Detect port: ':'\n      end = indexOfPort;\n    }\n  }\n\n  // Trim trailing dots\n  while (end > start + 1 && url.charCodeAt(end - 1) === 46 /* '.' */) {\n    end -= 1;\n  }\n\n  const hostname: string =\n    start !== 0 || end !== url.length ? url.slice(start, end) : url;\n\n  if (hasUpper) {\n    return hostname.toLowerCase();\n  }\n\n  return hostname;\n}\n","/**\n * Check if a hostname is an IP. You should be aware that this only works\n * because `hostname` is already garanteed to be a valid hostname!\n */\nfunction isProbablyIpv4(hostname: string): boolean {\n  // Cannot be shorted than 1.1.1.1\n  if (hostname.length < 7) {\n    return false;\n  }\n\n  // Cannot be longer than: 255.255.255.255\n  if (hostname.length > 15) {\n    return false;\n  }\n\n  let numberOfDots = 0;\n\n  for (let i = 0; i < hostname.length; i += 1) {\n    const code = hostname.charCodeAt(i);\n\n    if (code === 46 /* '.' */) {\n      numberOfDots += 1;\n    } else if (code < 48 /* '0' */ || code > 57 /* '9' */) {\n      return false;\n    }\n  }\n\n  return (\n    numberOfDots === 3 &&\n    hostname.charCodeAt(0) !== 46 /* '.' */ &&\n    hostname.charCodeAt(hostname.length - 1) !== 46 /* '.' */\n  );\n}\n\n/**\n * Similar to isProbablyIpv4.\n */\nfunction isProbablyIpv6(hostname: string): boolean {\n  if (hostname.length < 3) {\n    return false;\n  }\n\n  let start = hostname[0] === '[' ? 1 : 0;\n  let end = hostname.length;\n\n  if (hostname[end - 1] === ']') {\n    end -= 1;\n  }\n\n  // We only consider the maximum size of a normal IPV6. Note that this will\n  // fail on so-called \"IPv4 mapped IPv6 addresses\" but this is a corner-case\n  // and a proper validation library should be used for these.\n  if (end - start > 39) {\n    return false;\n  }\n\n  let hasColon: boolean = false;\n\n  for (; start < end; start += 1) {\n    const code = hostname.charCodeAt(start);\n\n    if (code === 58 /* ':' */) {\n      hasColon = true;\n    } else if ((\n      (code >= 48 && code <= 57) || // 0-9\n      (code >= 97 && code <= 102) || // a-f\n      (code >= 65 && code <= 90) // A-F\n    ) === false) {\n      return false;\n    }\n  }\n\n  return hasColon;\n}\n\n/**\n * Check if `hostname` is *probably* a valid ip addr (either ipv6 or ipv4).\n * This *will not* work on any string. We need `hostname` to be a valid\n * hostname.\n */\nexport default function isIp(hostname: string): boolean {\n  return isProbablyIpv6(hostname) || isProbablyIpv4(hostname);\n}\n","/**\n * Implements fast shallow verification of hostnames. This does not perform a\n * struct check on the content of labels (classes of Unicode characters, etc.)\n * but instead check that the structure is valid (number of labels, length of\n * labels, etc.).\n *\n * If you need stricter validation, consider using an external library.\n */\n\nfunction isValidAscii(code: number): boolean {\n  return (\n    (code >= 97 && code <= 122) || (code >= 48 && code <= 57) || code > 127\n  );\n}\n\n/**\n * Check if a hostname string is valid. It's usually a preliminary check before\n * trying to use getDomain or anything else.\n *\n * Beware: it does not check if the TLD exists.\n */\nexport default function(hostname: string): boolean {\n  if (hostname.length > 255) {\n    return false;\n  }\n\n  if (hostname.length === 0) {\n    return false;\n  }\n\n  if (!isValidAscii(hostname.charCodeAt(0))) {\n    return false;\n  }\n\n  // Validate hostname according to RFC\n  let lastDotIndex: number = -1;\n  let lastCharCode: number = -1;\n  const len = hostname.length;\n\n  for (let i = 0; i < len; i += 1) {\n    const code = hostname.charCodeAt(i);\n    if (code === 46 /* '.' */) {\n      if (\n        // Check that previous label is < 63 bytes long (64 = 63 + '.')\n        i - lastDotIndex > 64 ||\n        // Check that previous character was not already a '.'\n        lastCharCode === 46 ||\n        // Check that the previous label does not end with a '-' (dash)\n        lastCharCode === 45 ||\n        // Check that the previous label does not end with a '_' (underscore)\n        lastCharCode === 95\n      ) {\n        return false;\n      }\n\n      lastDotIndex = i;\n    } else if (!(isValidAscii(code) || code === 45 || code === 95)) {\n      // Check if there is a forbidden character in the label\n      return false;\n    }\n\n    lastCharCode = code;\n  }\n\n  return (\n    // Check that last label is shorter than 63 chars\n    len - lastDotIndex - 1 <= 63 &&\n    // Check that the last character is an allowed trailing label character.\n    // Since we already checked that the char is a valid hostname character,\n    // we only need to check that it's different from '-'.\n    lastCharCode !== 45\n  );\n}\n","export interface IOptions {\n  allowIcannDomains: boolean;\n  allowPrivateDomains: boolean;\n  detectIp: boolean;\n  extractHostname: boolean;\n  mixedInputs: boolean;\n  validHosts: string[] | null;\n  validateHostname: boolean;\n}\n\nfunction setDefaultsImpl({\n  allowIcannDomains = true,\n  allowPrivateDomains = false,\n  detectIp = true,\n  extractHostname = true,\n  mixedInputs = true,\n  validHosts = null,\n  validateHostname = true,\n}: Partial<IOptions>): IOptions {\n  return {\n    allowIcannDomains,\n    allowPrivateDomains,\n    detectIp,\n    extractHostname,\n    mixedInputs,\n    validHosts,\n    validateHostname,\n  };\n}\n\nconst DEFAULT_OPTIONS = setDefaultsImpl({});\n\nexport function setDefaults(options?: Partial<IOptions>): IOptions {\n  if (options === undefined) {\n    return DEFAULT_OPTIONS;\n  }\n\n  return setDefaultsImpl(options);\n}\n","/**\n * Returns the subdomain of a hostname string\n */\nexport default function getSubdomain(hostname: string, domain: string): string {\n  // If `hostname` and `domain` are the same, then there is no sub-domain\n  if (domain.length === hostname.length) {\n    return '';\n  }\n\n  return hostname.slice(0, -domain.length - 1);\n}\n","/**\n * Implement a factory allowing to plug different implementations of suffix\n * lookup (e.g.: using a trie or the packed hashes datastructures). This is used\n * and exposed in `tldts.ts` and `tldts-experimental.ts` bundle entrypoints.\n */\n\nimport getDomain from './domain';\nimport getDomainWithoutSuffix from './domain-without-suffix';\nimport extractHostname from './extract-hostname';\nimport isIp from './is-ip';\nimport isValidHostname from './is-valid';\nimport { IPublicSuffix, ISuffixLookupOptions } from './lookup/interface';\nimport { IOptions, setDefaults } from './options';\nimport getSubdomain from './subdomain';\n\nexport interface IResult {\n  // `hostname` is either a registered name (including but not limited to a\n  // hostname), or an IP address. IPv4 addresses must be in dot-decimal\n  // notation, and IPv6 addresses must be enclosed in brackets ([]). This is\n  // directly extracted from the input URL.\n  hostname: string | null;\n\n  // Is `hostname` an IP? (IPv4 or IPv6)\n  isIp: boolean | null;\n\n  // `hostname` split between subdomain, domain and its public suffix (if any)\n  subdomain: string | null;\n  domain: string | null;\n  publicSuffix: string | null;\n  domainWithoutSuffix: string | null;\n\n  // Specifies if `publicSuffix` comes from the ICANN or PRIVATE section of the list\n  isIcann: boolean | null;\n  isPrivate: boolean | null;\n}\n\nexport function getEmptyResult(): IResult {\n  return {\n    domain: null,\n    domainWithoutSuffix: null,\n    hostname: null,\n    isIcann: null,\n    isIp: null,\n    isPrivate: null,\n    publicSuffix: null,\n    subdomain: null,\n  };\n}\n\nexport function resetResult(result: IResult): void {\n  result.domain = null;\n  result.domainWithoutSuffix = null;\n  result.hostname = null;\n  result.isIcann = null;\n  result.isIp = null;\n  result.isPrivate = null;\n  result.publicSuffix = null;\n  result.subdomain = null;\n}\n\n// Flags representing steps in the `parse` function. They are used to implement\n// an early stop mechanism (simulating some form of laziness) to avoid doing\n// more work than necessary to perform a given action (e.g.: we don't need to\n// extract the domain and subdomain if we are only interested in public suffix).\nexport const enum FLAG {\n  HOSTNAME,\n  IS_VALID,\n  PUBLIC_SUFFIX,\n  DOMAIN,\n  SUB_DOMAIN,\n  ALL,\n}\n\nexport function parseImpl(\n  url: string,\n  step: FLAG,\n  suffixLookup: (\n    _1: string,\n    _2: ISuffixLookupOptions,\n    _3: IPublicSuffix,\n  ) => void,\n  partialOptions: Partial<IOptions>,\n  result: IResult,\n): IResult {\n  const options: IOptions = setDefaults(partialOptions);\n\n  // Very fast approximate check to make sure `url` is a string. This is needed\n  // because the library will not necessarily be used in a typed setup and\n  // values of arbitrary types might be given as argument.\n  if (typeof url !== 'string') {\n    return result;\n  }\n\n  // Extract hostname from `url` only if needed. This can be made optional\n  // using `options.extractHostname`. This option will typically be used\n  // whenever we are sure the inputs to `parse` are already hostnames and not\n  // arbitrary URLs.\n  //\n  // `mixedInput` allows to specify if we expect a mix of URLs and hostnames\n  // as input. If only hostnames are expected then `extractHostname` can be\n  // set to `false` to speed-up parsing. If only URLs are expected then\n  // `mixedInputs` can be set to `false`. The `mixedInputs` is only a hint\n  // and will not change the behavior of the library.\n  if (options.extractHostname === false) {\n    result.hostname = url;\n  } else if (options.mixedInputs === true) {\n    result.hostname = extractHostname(url, isValidHostname(url));\n  } else {\n    result.hostname = extractHostname(url, false);\n  }\n\n  if (step === FLAG.HOSTNAME || result.hostname === null) {\n    return result;\n  }\n\n  // Check if `hostname` is a valid ip address\n  if (options.detectIp === true) {\n    result.isIp = isIp(result.hostname);\n    if (result.isIp === true) {\n      return result;\n    }\n  }\n\n  // Perform optional hostname validation. If hostname is not valid, no need to\n  // go further as there will be no valid domain or sub-domain.\n  if (\n    options.validateHostname === true &&\n    options.extractHostname === true &&\n    isValidHostname(result.hostname) === false\n  ) {\n    result.hostname = null;\n    return result;\n  }\n\n  // Extract public suffix\n  suffixLookup(result.hostname, options, result);\n  if (step === FLAG.PUBLIC_SUFFIX || result.publicSuffix === null) {\n    return result;\n  }\n\n  // Extract domain\n  result.domain = getDomain(result.publicSuffix, result.hostname, options);\n  if (step === FLAG.DOMAIN || result.domain === null) {\n    return result;\n  }\n\n  // Extract subdomain\n  result.subdomain = getSubdomain(result.hostname, result.domain);\n  if (step === FLAG.SUB_DOMAIN) {\n    return result;\n  }\n\n  // Extract domain without suffix\n  result.domainWithoutSuffix = getDomainWithoutSuffix(\n    result.domain,\n    result.publicSuffix,\n  );\n\n  return result;\n}\n","import { IPublicSuffix, ISuffixLookupOptions } from './interface';\n\nexport default function(\n  hostname: string,\n  options: ISuffixLookupOptions,\n  out: IPublicSuffix,\n): boolean {\n  // Fast path for very popular suffixes; this allows to by-pass lookup\n  // completely as well as any extra allocation or string manipulation.\n  if (options.allowPrivateDomains === false && hostname.length > 3) {\n    const last: number = hostname.length - 1;\n    const c3: number = hostname.charCodeAt(last);\n    const c2: number = hostname.charCodeAt(last - 1);\n    const c1: number = hostname.charCodeAt(last - 2);\n    const c0: number = hostname.charCodeAt(last - 3);\n\n    if (\n      c3 === 109 /* 'm' */ &&\n      c2 === 111 /* 'o' */ &&\n      c1 === 99 /* 'c' */ &&\n      c0 === 46 /* '.' */\n    ) {\n      out.isIcann = true;\n      out.isPrivate = false;\n      out.publicSuffix = 'com';\n      return true;\n    } else if (\n      c3 === 103 /* 'g' */ &&\n      c2 === 114 /* 'r' */ &&\n      c1 === 111 /* 'o' */ &&\n      c0 === 46 /* '.' */\n    ) {\n      out.isIcann = true;\n      out.isPrivate = false;\n      out.publicSuffix = 'org';\n      return true;\n    } else if (\n      c3 === 117 /* 'u' */ &&\n      c2 === 100 /* 'd' */ &&\n      c1 === 101 /* 'e' */ &&\n      c0 === 46 /* '.' */\n    ) {\n      out.isIcann = true;\n      out.isPrivate = false;\n      out.publicSuffix = 'edu';\n      return true;\n    } else if (\n      c3 === 118 /* 'v' */ &&\n      c2 === 111 /* 'o' */ &&\n      c1 === 103 /* 'g' */ &&\n      c0 === 46 /* '.' */\n    ) {\n      out.isIcann = true;\n      out.isPrivate = false;\n      out.publicSuffix = 'gov';\n      return true;\n    } else if (\n      c3 === 116 /* 't' */ &&\n      c2 === 101 /* 'e' */ &&\n      c1 === 110 /* 'n' */ &&\n      c0 === 46 /* '.' */\n    ) {\n      out.isIcann = true;\n      out.isPrivate = false;\n      out.publicSuffix = 'net';\n      return true;\n    } else if (\n      c3 === 101 /* 'e' */ &&\n      c2 === 100 /* 'd' */ &&\n      c1 === 46 /* '.' */\n    ) {\n      out.isIcann = true;\n      out.isPrivate = false;\n      out.publicSuffix = 'de';\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"names":[],"mappings":"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"}